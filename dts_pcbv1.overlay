/ {
	chosen {
		ncs,zigbee-timer = &timer20;
		/* zephyr,console = &uart20; */
	};

	zephyr,user {
		io-channels = <&adc 0>;
	};

	leds {
		compatible = "gpio-leds";
		led0: led_0 {
			gpios = <&gpio2 9 GPIO_ACTIVE_HIGH>;
			label = "Red LED 0";
		};
	};

	buttons {
		compatible = "gpio-keys";
		button0: button_0 {
			gpios = <&gpio0 4 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>;
			label = "Identify/FactoryReset";
			zephyr,code = <INPUT_KEY_0>;
		};
		button1: button_1 {
			gpios = <&gpio1 10 (GPIO_PULL_UP | GPIO_ACTIVE_LOW)>;
			label = "Btn2";
			zephyr,code = <INPUT_KEY_1>;
		};
	};

	aliases {
		led0 = &led0;
	};

	/* Define the GPIO-controlled regulator */
	scd41_power: scd41-power-regulator {
		compatible = "regulator-fixed"; // Standard binding for fixed regulators
		regulator-name = "scd41_power_reg";
		status = "okay";

		/* GPIO controlling the MOSFET gate */
		/* GPIO_ACTIVE_HIGH means the sensor is ON when GPIO is high */
		/* Use GPIO_ACTIVE_LOW if your MOSFET logic is inverted */
		enable-gpios = <&gpio0 3 GPIO_ACTIVE_HIGH>;

		/* Optional: Define the voltage being regulated */
		// regulator-min-microvolt = ; // e.g., 3.3V
		// regulator-max-microvolt = ; // e.g., 3.3V

		/* Optional: Delay after enabling GPIO before regulator is considered stable */
		startup-delay-us = <1300000>; // 1us, adjust based on MOSFET and sensor VCC rise time

		/* Optional: Specify that this regulator should be off initially */
		//regulator-boot-on; // Remove or comment out if you want it initially OFF
	};

	/* Define the GPIO-controlled regulator */
	battery_measure: battery-measure-regulator {
		compatible = "regulator-fixed"; // Standard binding for fixed regulators
		regulator-name = "battery_measure_reg";
		status = "okay";

		/* GPIO controlling the MOSFET gate */
		/* GPIO_ACTIVE_HIGH means the sensor is ON when GPIO is high */
		/* Use GPIO_ACTIVE_LOW if your MOSFET logic is inverted */
		enable-gpios = <&gpio0 2 GPIO_ACTIVE_LOW>;

		/* Optional: Define the voltage being regulated */
		// regulator-min-microvolt = ; // e.g., 3.3V
		// regulator-max-microvolt = ; // e.g., 3.3V

		/* Optional: Delay after enabling GPIO before regulator is considered stable */
		startup-delay-us = <1>; // 1us, adjust based on MOSFET and sensor VCC rise time

		/* Optional: Specify that this regulator should be off initially */
		// regulator-boot-on; // Remove or comment out if you want it initially OFF
	};
};

// restore full RRAM and SRAM space - by default some parts are dedicated to FLRP
//&cpuapp_rram {
//	reg = <0x0 DT_SIZE_K(1524)>;
//};
//
//&cpuapp_sram {
//	reg = <0x20000000 DT_SIZE_K(256)>;
//	ranges = <0x0 0x20000000  0x40000>;
//};

&pinctrl {
	i2c30_default_alt: i2c30_default_alt {
		group1 {
			psels = <NRF_PSEL(TWIM_SDA, 0, 1)>,
				<NRF_PSEL(TWIM_SCL, 0, 0)>;
		};
	};
	i2c30_sleep_alt: i2c30_sleep_alt {
		group1 {
			psels = <NRF_PSEL(TWIM_SDA, 0, 1)>,
				<NRF_PSEL(TWIM_SCL, 0, 0)>;
				low-power-enable;
		};
	};
/omit-if-no-ref/ uart20_default: uart20_default {
	//forgot extra UART pin to route. re-suing btn2 for this
	group1 {
		psels = <NRF_PSEL(UART_TX, 1, 10)>;
	};
};

/omit-if-no-ref/ uart20_sleep: uart20_sleep {
	group1 {
		psels = <NRF_PSEL(UART_TX, 1, 10)>;
		low-power-enable;
	};
};
};


&i2c30 {
	status = "okay";
	pinctrl-0 = <&i2c30_default_alt>;
	pinctrl-1 = <&i2c30_sleep_alt>;
	pinctrl-names = "default", "sleep";

	co2sensor: scd41@62{
		compatible="sensirion,scd41";
		reg = <0x62>;
		label = "SCD41";
		/* mode 2 = single shot */
		/* mode 1 = low power */
		/* mode 0 = normal */
		mode = < 2 >;
		status = "okay";
		zephyr,deferred-init;
	};
};

&adc {
	status = "okay";
	#address-cells = <1>;
	#size-cells = <0>;

	channel@0 {
		reg = <0>;
		zephyr,gain = "ADC_GAIN_1_4";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,input-positive = <NRF_SAADC_AIN3>; /* P1.07 */
		zephyr,resolution = <12>;
	};
};

&timer20 {
	status = "okay";
};

&uart20 {
	status = "okay";
	current-speed = <115200>;
};
&gpio2 {
	status = "okay";
};
